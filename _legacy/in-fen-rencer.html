<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FEN Chess Analyzer - Avalia√ß√£o Est√°tica Completa</title>
    <style>
        /* Vari√°veis de Layout */
        :root {
            --square-size: 60px;
            --board-size: calc(8 * var(--square-size));
            --coord-size: 20px;
            --border-width: 5px;
            --panel-width: 380px; /* Aumentado para mais infos */
            --main-color: #4CAF50; /* Verde */
            --blocked-color: #d9534f; /* Vermelho (Bloqueado/Pendente) */
            --limited-color: #f0ad4e; /* Laranja (Limitado/Sobrecarregado) */
            --highlight-color: #3f7b9e; /* Azul Escuro */
            --network-color: #9c27b0; /* Roxo */
            --positive-score: #006400; /* Verde Escuro */
            --negative-score: #8B0000; /* Vermelho Escuro */

            /* CORES NOVAS: Hierarquia de Impacto (Roxo) */
            --net-dark-purple: rgba(100, 0, 150, 0.7); /* Roxo Escuro: Pe√ßa de Maior Impacto (Rei/Foco) */
            --net-light-purple: rgba(180, 100, 200, 0.5); /* Roxo Claro: Pe√ßas de Impacto Secund√°rio (Torre/Pe√£o/Defensoras) */
        }

        /* Estrutura Principal */
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f4;
        }

        #main-content {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 30px;
            width: 100%;
            max-width: 1250px; /* Aumentado */
        }

        h1, p { text-align: center; width: 100%; }
        .input-group { text-align: center; margin-bottom: 20px; width: 100%; }
        #fen-input { width: 400px; padding: 10px; font-size: 16px; border: 1px solid #ccc; }
        #parse-button { padding: 10px 15px; font-size: 16px; cursor: pointer; background-color: var(--main-color); color: white; border: none; margin-left: 10px; }
        #validation-message { margin-top: 10px; font-weight: bold; }

        /* --- Tabuleiro --- */
        #board-wrapper {
            width: calc(var(--board-size) + var(--coord-size) + var(--border-width));
            height: calc(var(--board-size) + var(--coord-size) + var(--border-width));
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            position: relative; 
        }

        #board-area {
            display: flex;
            width: 100%;
            height: var(--board-size);
            margin-bottom: var(--border-width);
        }

        #rank-coords {
            display: grid;
            grid-template-rows: repeat(8, var(--square-size));
            width: var(--coord-size);
            text-align: center;
            font-weight: bold;
            font-size: 12px;
            line-height: var(--square-size);
            padding-right: var(--border-width);
        }

        #chessboard-container {
            display: grid;
            grid-template-columns: repeat(8, var(--square-size));
            grid-template-rows: repeat(8, var(--square-size));
            width: var(--board-size); 
            height: var(--board-size);
            border: var(--border-width) solid #333; 
            margin: 0;
            position: relative; 
        }

        .square {
            display: flex; justify-content: center; align-items: center;
            font-size: 45px; cursor: pointer; user-select: none;
            position: relative; 
        }
        
        .square.highlight {
            box-shadow: inset 0 0 0 4px var(--highlight-color);
        }

        .light { background-color: #f0d9b5; }
        .dark { background-color: #b58863; }
        .white-piece { color: white; text-shadow: 1px 1px 2px #333; }
        .black-piece { color: black; }

        /* Estilos de Rede Ativa (HIERARQUIA DE CORES) */
        .square.net-dark { background-color: var(--net-dark-purple) !important; }
        .square.net-light { background-color: var(--net-light-purple) !important; }


        #file-coords {
            display: grid;
            grid-template-columns: repeat(8, var(--square-size));
            height: var(--coord-size);
            line-height: var(--coord-size);
            font-weight: bold;
            font-size: 12px;
            text-align: center;
            padding-left: calc(var(--coord-size) + var(--border-width));
        }

        /* --- Painel Lateral de An√°lise --- */
        #analysis-panel {
            width: var(--panel-width);
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 20px;
            overflow-y: auto;
            max-height: 90vh;
        }
        
        #analysis-panel h2 { border-bottom: 2px solid #eee; padding-bottom: 5px; color: #333; margin-top: 0; }
        .card { border: 1px solid #ddd; padding: 15px; margin-bottom: 15px; border-radius: 6px; background-color: #fafafa; }
        .card-header { font-weight: bold; color: var(--main-color); margin-bottom: 10px; font-size: 1.1em; }
        
        /* NOVO: Header com cores */
        .card-header-white { background-color: #f8f8f8; color: #333; }
        .card-header-black { background-color: #555; color: white; }
        .card-header-neutral { background-color: #337ab7; color: white; }
        .card-header-pawn { background-color: #778899; color: white; }
        .card-header-king { background-color: #FFD700; color: #333; }
        
        .metric-list { list-style: none; padding: 0; margin: 0; }
        .metric-list li { padding: 3px 0; border-bottom: 1px dashed #eee; display: flex; justify-content: space-between; align-items: center; }
        .metric-list li:last-child { border-bottom: none; }
        .metric-list .metric-value { font-weight: bold; text-align: right; }
        .metric-list .metric-value.positive { color: var(--positive-score); }
        .metric-list .metric-value.negative { color: var(--negative-score); }
        
        .contact-item { font-size: 0.9em; padding: 5px 0; border-bottom: 1px dotted #ccc; }
        .contact-item span.attack { color: red; font-weight: bold; }
        .contact-item span.defense { color: blue; }
        .contact-item span.network { color: var(--network-color); font-weight: bold; }

        .status-blocked, .status-hanging { color: var(--blocked-color); font-weight: bold; }
        .status-limited, .status-overloaded { color: var(--limited-color); font-weight: bold; }
        
        /* Estilo para cards de detalhes (Casa/Pe√ßa) */
        #clicked-square-details .card-header,
        #clicked-piece-details .card-header { 
            background-color: var(--highlight-color); 
            color: white; 
            padding: 8px 10px;
            margin: -15px -15px 10px -15px;
            border-top-left-radius: 6px;
            border-top-right-radius: 6px;
            font-size: 1.2em;
        }
        
        .hidden-detail-card { display: none; }
        
        #clear-network-button {
            padding: 5px 10px; font-size: 14px; cursor: pointer;
            background-color: var(--blocked-color); color: white;
            border: none; border-radius: 4px; margin-top: 10px; width: 100%;
        }
        
        /* NOVO: Estilo para Sum√°rio de Pontua√ß√£o */
        #score-summary-card {
            background-color: #333;
            color: white;
            padding: 20px;
            text-align: center;
        }
        #score-summary-card h2 {
            margin: 0 0 10px 0;
            border-bottom: 1px solid #555;
            padding-bottom: 10px;
        }
        #total-score-display {
            font-size: 2.5em;
            font-weight: bold;
        }
        #score-breakdown {
            font-size: 0.9em;
            color: #ccc;
        }
    </style>
</head>
<body>

    <h1>‚ôüÔ∏è FEN Chess Analyzer - Avalia√ß√£o Est√°tica</h1>
    
    <div class="input-group">
        <input type="text" id="fen-input" value="4r1k1/5ppp/p2B1n2/8/2pP4/2q4P/P4PP1/1Q2R1K1 w - - 0 1">
        <button id="parse-button">Analisar & Renderizar</button>
        <div id="validation-message"></div>
    </div>
    
    <div id="main-content">
        <div id="board-wrapper">
            <div id="board-area">
                <div id="rank-coords"></div>
                <div id="chessboard-container">
                </div>
            </div>
            <div id="file-coords"></div>
        </div>

        <aside id="analysis-panel">
            
            <div id="clicked-piece-details" class="hidden-detail-card">
                <div class="card">
                    <div class="card-header">Clique em uma pe√ßa para an√°lise at√¥mica...</div>
                </div>
            </div>
            
            <div id="clicked-square-details" class="hidden-detail-card">
                <div class="card">
                    <div class="card-header">Clique em uma casa para analisar...</div>
                </div>
            </div>

            <div id="score-summary-card" class="card">
                <h2>Pontua√ß√£o Total</h2>
                <div id="total-score-display">+0.00</div>
                <div id="score-breakdown">(Material + Posi√ß√£o)</div>
            </div>

            <div id="material-balance-card" class="card">
                <div class="card-header card-header-neutral" style="background-color: #607D8B;">‚öñÔ∏è Balan√ßo Material</div>
                <ul class="metric-list" id="material-balance-list">
                    <li>Aguardando an√°lise...</li>
                </ul>
            </div>
            
            <div id="positional-score-card" class="card">
                <div class="card-header card-header-neutral" style="background-color: #0277BD;">üó∫Ô∏è Vantagem Posicional (PST)</div>
                <ul class="metric-list" id="positional-score-list">
                    <li>Aguardando an√°lise...</li>
                </ul>
            </div>
            
            <div id="pawn-structure-card" class="card">
                <div class="card-header card-header-pawn">‚ôüÔ∏è Estrutura de Pe√µes</div>
                <div id="pawn-structure-analysis">Aguardando an√°lise...</div>
            </div>

            <div id="king-safety-card" class="card">
                <div class="card-header card-header-king">üëë Seguran√ßa do Rei</div>
                <div id="king-safety-analysis">Aguardando an√°lise...</div>
            </div>

            <div id="board-overview" class="card" style="margin-top: 20px;">
                <div class="card-header card-header-neutral">üìã Vis√£o Geral de Pe√ßas</div>
                <ul id="overview-list" class="metric-list" style="max-height: 250px; overflow-y: auto;">
                    <li>Aguardando an√°lise...</li>
                </ul>
            </div>
            
            <h2>üîé Detalhes da Posi√ß√£o (T√°ticas Imediatas)</h2>
            
            <div id="network-controls" class="card" style="margin-top: 10px;">
                <div class="card-header" style="background-color: var(--network-color); color: white;">üîó Visualizar Redes</div>
                <div style="padding: 5px;">
                    <label for="network-selector">Rede (Impacto) #:</label>
                    <select id="network-selector" style="width: 70%;" disabled>
                        <option value="none">Nenhuma</option>
                    </select>
                    <button id="clear-network-button" disabled>Limpar Visualiza√ß√£o</button>
                </div>
            </div>
            
            <div id="analysis-results">
                <p>Aguardando an√°lise...</p>
            </div>
        </aside>
    </div>

    <script>
        // --- CONSTANTES E VARI√ÅVEIS GLOBAIS ---
        const PIECE_MAP = {
            'r': '‚ôú', 'n': '‚ôû', 'b': '‚ôù', 'q': '‚ôõ', 'k': '‚ôö', 'p': '‚ôü', 
            'R': '‚ôñ', 'N': '‚ôò', 'B': '‚ôó', 'Q': '‚ôï', 'K': '‚ôî', 'P': '‚ôô', 
        };
        const VALID_PIECES = 'rnbqkpRNBQKP';
        const RANKS = ['8', '7', '6', '5', '4', '3', '2', '1']; // Fileiras [0] a [7] (do topo para baixo)
        const FILES = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']; // Colunas
        
        // NOVO: Valor das Pe√ßas (em pontos de pe√£o)
        const PIECE_VALUES = {
            'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9, 'k': 0,
            'P': 1, 'N': 3, 'B': 3, 'R': 5, 'Q': 9, 'K': 0
        };

        // NOVO: Piece-Square Tables (PST) - Valores em Centipawns (100 = 1 pe√£o)
        // Tabelas padr√£o (simplificadas) para "meio de jogo"
        const PST_PAWN = [
             0,  0,  0,  0,  0,  0,  0,  0,
             5, 10, 10,-20,-20, 10, 10,  5,
             5, -5,-10,  0,  0,-10, -5,  5,
             0,  0,  0, 20, 20,  0,  0,  0,
             5,  5, 10, 25, 25, 10,  5,  5,
            10, 10, 20, 30, 30, 20, 10, 10,
            50, 50, 50, 50, 50, 50, 50, 50,
             0,  0,  0,  0,  0,  0,  0,  0
        ];
        const PST_KNIGHT = [
            -50,-40,-30,-30,-30,-30,-40,-50,
            -40,-20,  0,  5,  5,  0,-20,-40,
            -30,  5, 10, 15, 15, 10,  5,-30,
            -30,  0, 15, 20, 20, 15,  0,-30,
            -30,  5, 15, 20, 20, 15,  5,-30,
            -30,  0, 10, 15, 15, 10,  0,-30,
            -40,-20,  0,  0,  0,  0,-20,-40,
            -50,-40,-30,-30,-30,-30,-40,-50
        ];
        const PST_BISHOP = [
            -20,-10,-10,-10,-10,-10,-10,-20,
            -10,  5,  0,  0,  0,  0,  5,-10,
            -10, 10, 10, 10, 10, 10, 10,-10,
            -10,  0, 10, 10, 10, 10,  0,-10,
            -10,  5,  5, 10, 10,  5,  5,-10,
            -10,  0,  5, 10, 10,  5,  0,-10,
            -10,  0,  0,  0,  0,  0,  0,-10,
            -20,-10,-10,-10,-10,-10,-10,-20
        ];
        const PST_ROOK = [
             0,  0,  0,  5,  5,  0,  0,  0,
            -5,  0,  0,  0,  0,  0,  0, -5,
            -5,  0,  0,  0,  0,  0,  0, -5,
            -5,  0,  0,  0,  0,  0,  0, -5,
            -5,  0,  0,  0,  0,  0,  0, -5,
            -5,  0,  0,  0,  0,  0,  0, -5,
             5, 10, 10, 10, 10, 10, 10,  5,
             0,  0,  0,  0,  0,  0,  0,  0
        ];
        const PST_QUEEN = [
            -20,-10,-10, -5, -5,-10,-10,-20,
            -10,  0,  5,  0,  0,  0,  0,-10,
            -10,  5,  5,  5,  5,  5,  0,-10,
             0,  0,  5,  5,  5,  5,  0, -5,
            -5,  0,  5,  5,  5,  5,  0, -5,
            -10,  0,  5,  5,  5,  5,  0,-10,
            -10,  0,  0,  0,  0,  0,  0,-10,
            -20,-10,-10, -5, -5,-10,-10,-20
        ];
        // PST do Rei (prioriza roque e centro seguro)
        const PST_KING_MIDDLE = [
             20, 30, 10,  0,  0, 10, 30, 20,
             20, 20,  0,  0,  0,  0, 20, 20,
            -10,-20,-20,-20,-20,-20,-20,-10,
            -20,-30,-30,-40,-40,-30,-30,-20,
            -30,-40,-40,-50,-50,-40,-40,-30,
            -30,-40,-40,-50,-50,-40,-40,-30,
            -30,-40,-40,-50,-50,-40,-40,-30,
            -30,-40,-40,-50,-50,-40,-40,-30
        ];
        
        const PST_MAP = {
            'p': PST_PAWN, 'P': PST_PAWN,
            'n': PST_KNIGHT, 'N': PST_KNIGHT,
            'b': PST_BISHOP, 'B': PST_BISHOP,
            'r': PST_ROOK, 'R': PST_ROOK,
            'q': PST_QUEEN, 'Q': PST_QUEEN,
            'k': PST_KING_MIDDLE, 'K': PST_KING_MIDDLE
        };
        
        let globalAnalysisResult = null; 
        let activeNetworkId = 'none'; 

        // --- FUN√á√ïES DE UTENS√çLIO E M√âTODOS DE BUSCA ---
        function getPieceAtSquare(squareName, board) {
             const fileIndex = FILES.indexOf(squareName[0]);
             const rankIndex = RANKS.indexOf(squareName[1]);
             if (fileIndex === -1 || rankIndex === -1 || !board) return null;
             return board[rankIndex][fileIndex];
        }
        
        const getSquareName = (r, c) => `${FILES[c]}${RANKS[r]}`; 

        // --- FUN√á√ïES DE PARSING E AN√ÅLISE ---
        
        function parseFenToData(fen) {
            const data = {
                isValid: false, message: 'FEN inv√°lido', board: null, activeColor: null, 
                castling: null, enPassant: null, halfMoveClock: null, fullMoveNumber: null
            };
            const parts = fen.trim().split(' ');
            if (parts.length !== 6) { data.message = 'FEN deve ter 6 campos.'; return data; }

            const [piecesStr, activeColor, castling, enPassant, halfMoveClockStr, fullMoveNumberStr] = parts;
            const ranksArr = piecesStr.split('/');
            if (ranksArr.length !== 8) { data.message = 'A disposi√ß√£o das pe√ßas deve ter 8 fileiras.'; return data; }

            const board = [];
            for (let r = 0; r < 8; r++) {
                let rank = [];
                let squareCount = 0;
                for (const char of ranksArr[r]) {
                    if (VALID_PIECES.includes(char)) {
                        rank.push({ 
                            piece: char, 
                            square: `${FILES[squareCount]}${RANKS[r]}`, 
                            color: char === char.toUpperCase() ? 'white' : 'black',
                            r: r, // Salva coordenadas para facilitar
                            c: squareCount // Salva coordenadas para facilitar
                        });
                        squareCount++;
                    } else if (/\d/.test(char)) {
                        const numEmpty = parseInt(char);
                        for (let j = 0; j < numEmpty; j++) { rank.push(null); }
                        squareCount += numEmpty;
                    } else { data.message = `Caractere inv√°lido: "${char}".`; return data; }
                }
                if (squareCount !== 8) { data.message = `A fileira ${RANKS[r]} tem ${squareCount} casas, o esperado √© 8.`; return data; }
                board.push(rank);
            }
            data.board = board;

            if (!['w', 'b'].includes(activeColor)) { data.message = 'Cor ativa inv√°lida.'; return data; }
            data.activeColor = activeColor;
            data.castling = castling;
            data.enPassant = enPassant;
            data.halfMoveClock = parseInt(halfMoveClockStr);
            data.fullMoveNumber = parseInt(fullMoveNumberStr);

            data.isValid = true;
            data.message = 'FEN analisado com sucesso.';
            return data;
        }

        /**
         * NOVO: Conta material ponderado e pe√ßas.
         */
        function analyzeMaterialAndCounts(board) {
            const counts = { total: 0, white: 0, black: 0, byType: { K: 0, Q: 0, R: 0, B: 0, N: 0, P: 0, k: 0, q: 0, r: 0, b: 0, n: 0, p: 0 } };
            const material = { white: 0, black: 0, balance: 0 };
            
            board.flat().forEach(square => {
                if (square && square.piece) {
                    const piece = square.piece;
                    counts.total++;
                    counts.byType[piece]++;
                    
                    const value = PIECE_VALUES[piece];
                    if (square.color === 'white') {
                        counts.white++;
                        material.white += value;
                    } else {
                        counts.black++;
                        material.black += value;
                    }
                }
            });
            material.balance = material.white - material.black;
            return { counts, material };
        }
        
        /**
         * NOVO: Calcula a pontua√ß√£o posicional (PST) em centipawns.
         */
        function analyzePositionalScore(board) {
            let scoreWhite = 0;
            let scoreBlack = 0;
            
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const pieceObj = board[r][c];
                    if (!pieceObj) continue;
                    
                    const piece = pieceObj.piece;
                    const pst = PST_MAP[piece];
                    if (!pst) continue;
                    
                    let index;
                    if (pieceObj.color === 'white') {
                        // Para brancas, a tabela √© lida do in√≠cio (r=0 √© fileira 8)
                        // Nossas tabelas est√£o definidas de A8 (√≠ndice 0) para H1 (√≠ndice 63)
                        index = r * 8 + c;
                        scoreWhite += pst[index];
                    } else {
                        // Para pretas, a tabela √© espelhada verticalmente
                        // O 'r' da preta √© (7-r) para a branca
                        index = (7 - r) * 8 + c;
                        scoreBlack += pst[index];
                    }
                }
            }
            
            const balance = (scoreWhite - scoreBlack) / 100; // Converte para pe√µes
            
            return {
                white: scoreWhite,
                black: scoreBlack,
                balance: balance
            };
        }
        
        /**
         * NOVO: Analisa a estrutura de pe√µes (Dobrados, Isolados, Passados).
         */
        function analyzePawnStructure(board) {
            const whitePawns = [];
            const blackPawns = [];
            const pawnsByFile = Array(8).fill(null).map(() => ({ white: [], black: [] }));

            board.flat().forEach(p => {
                if (p && p.piece.toUpperCase() === 'P') {
                    if (p.color === 'white') {
                        whitePawns.push(p);
                        pawnsByFile[p.c].white.push(p);
                    } else {
                        blackPawns.push(p);
                        pawnsByFile[p.c].black.push(p);
                    }
                }
            });
            
            const structure = {
                white: { doubled: [], isolated: [], passed: [] },
                black: { doubled: [], isolated: [], passed: [] }
            };

            for (let c = 0; c < 8; c++) {
                const whiteInFile = pawnsByFile[c].white;
                const blackInFile = pawnsByFile[c].black;
                
                // 1. Pe√µes Dobrados
                if (whiteInFile.length > 1) whiteInFile.forEach(p => structure.white.doubled.push(p.square));
                if (blackInFile.length > 1) blackInFile.forEach(p => structure.black.doubled.push(p.square));
                
                // 2. Pe√µes Isolados
                const noAdjacentWhite = (pawnsByFile[c-1]?.white.length === 0) && (pawnsByFile[c+1]?.white.length === 0);
                if (whiteInFile.length > 0 && noAdjacentWhite) whiteInFile.forEach(p => structure.white.isolated.push(p.square));
                
                const noAdjacentBlack = (pawnsByFile[c-1]?.black.length === 0) && (pawnsByFile[c+1]?.black.length === 0);
                if (blackInFile.length > 0 && noAdjacentBlack) blackInFile.forEach(p => structure.black.isolated.push(p.square));
            }
            
            // 3. Pe√µes Passados (mais complexo)
            whitePawns.forEach(p => {
                let isPassed = true;
                for (let fc = p.c - 1; fc <= p.c + 1; fc++) {
                    if (fc < 0 || fc > 7) continue;
                    // Se houver qualquer pe√£o preto *√† frente* (r < p.r), n√£o √© passado
                    if (pawnsByFile[fc].black.some(bp => bp.r < p.r)) {
                        isPassed = false;
                        break;
                    }
                }
                if (isPassed) structure.white.passed.push(p.square);
            });
            
            blackPawns.forEach(p => {
                let isPassed = true;
                for (let fc = p.c - 1; fc <= p.c + 1; fc++) {
                    if (fc < 0 || fc > 7) continue;
                    // Se houver qualquer pe√£o branco *√† frente* (r > p.r), n√£o √© passado
                    if (pawnsByFile[fc].white.some(wp => wp.r > p.r)) {
                        isPassed = false;
                        break;
                    }
                }
                if (isPassed) structure.black.passed.push(p.square);
            });

            return structure;
        }

        /**
         * NOVO: Analisa a seguran√ßa do Rei (Escudo de Pe√µes, Arquivos Abertos).
         */
        function analyzeKingSafety(board) {
            const kings = { white: null, black: null };
            const pawnsByFile = Array(8).fill(null).map(() => ({ white: 0, black: 0 }));

            board.flat().forEach(p => {
                if (!p) return;
                if (p.piece === 'K') kings.white = p;
                else if (p.piece === 'k') kings.black = p;
                else if (p.piece === 'P') pawnsByFile[p.c].white++;
                else if (p.piece === 'p') pawnsByFile[p.c].black++;
            });

            const safety = {
                white: { shield: 0, openFiles: [] },
                black: { shield: 0, openFiles: [] }
            };

            // Fun√ß√£o auxiliar para verificar o escudo
            const checkShield = (king, color) => {
                if (!king) return 0;
                let score = 0;
                const shieldR = (color === 'white') ? king.r - 1 : king.r + 1; // Fileira √† frente do rei
                if (shieldR < 0 || shieldR > 7) return 0; // Rei na borda

                for (let dc = -1; dc <= 1; dc++) {
                    const shieldC = king.c + dc;
                    if (shieldC < 0 || shieldC > 7) continue;
                    
                    const piece = board[shieldR][shieldC];
                    if (piece && piece.piece.toUpperCase() === 'P' && piece.color === color) {
                        score += 1; // Bom: pe√£o amigo
                    } else if (!piece) {
                        score -= 1; // Ruim: casa vazia
                    }
                    // Pe√£o inimigo ou outra pe√ßa: n√£o pontua
                }
                return score;
            };

            safety.white.shield = checkShield(kings.white, 'white');
            safety.black.shield = checkShield(kings.black, 'black');

            // Fun√ß√£o auxiliar para verificar arquivos abertos
            const checkOpenFiles = (king) => {
                if (!king) return [];
                const open = [];
                for (let dc = -1; dc <= 1; dc++) {
                    const file = king.c + dc;
                    if (file < 0 || file > 7) continue;
                    
                    if (pawnsByFile[file].white === 0 && pawnsByFile[file].black === 0) {
                        open.push({ file: FILES[file], type: 'Aberto' });
                    } else if (pawnsByFile[file].white === 0 || pawnsByFile[file].black === 0) {
                        open.push({ file: FILES[file], type: 'Semi-Aberto' });
                    }
                }
                return open;
            };

            safety.white.openFiles = checkOpenFiles(kings.white);
            safety.black.openFiles = checkOpenFiles(kings.black);
            
            return safety;
        }

        /**
         * Realiza a an√°lise de controle de casas, mobilidade e contatos.
         */
        function analyzeBoard(board) {
            const MOVES = {
                P: [{dr: -1, dc: -1}, {dr: -1, dc: 1}], // Pe√£o Branco: Captura (controle)
                p: [{dr: 1, dc: -1}, {dr: 1, dc: 1}],   // Pe√£o Preto: Captura (controle)
                N: [{dr: -2, dc: -1}, {dr: -2, dc: 1}, {dr: -1, dc: -2}, {dr: -1, dc: 2}, {dr: 1, dc: -2}, {dr: 1, dc: 2}, {dr: 2, dc: -1}, {dr: 2, dc: 1}],
                R: [{dr: 0, dc: 1}, {dr: 0, dc: -1}, {dr: 1, dc: 0}, {dr: -1, dc: 0}],
                B: [{dr: 1, dc: 1}, {dr: 1, dc: -1}, {dr: -1, dc: 1}, {dr: -1, dc: -1}],
                Q: [{dr: 0, dc: 1}, {dr: 0, dc: -1}, {dr: 1, dc: 0}, {dr: -1, dc: 0}, {dr: 1, dc: 1}, {dr: 1, dc:-1}, {dr: -1, dc: 1}, {dr: -1, dc: -1}],
                K: [{dr: 0, dc: 1}, {dr: 0, dc: -1}, {dr: 1, dc: 0}, {dr: -1, dc: 0}, {dr: 1, dc: 1}, {dr: 1, dc: -1}, {dr: -1, dc: 1}, {dr: -1, dc: -1}]
            };

            const controlledSquares = { white: {}, black: {}, total: 0 };
            const contacts = []; 
            const pieceMobility = {}; 
            
            const contactsByTarget = {}; 
            const contactsByAttacker = {}; 
            
            const isOppositeColor = (piece1, piece2) => (piece1 === piece1.toUpperCase()) !== (piece2 === piece2.toUpperCase());
            
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const pieceObj = board[r][c];
                    if (!pieceObj) continue;

                    const { piece, square, color } = pieceObj;
                    const pieceType = piece.toUpperCase();
                    
                    pieceMobility[square] = { total: 0, contacts: 0, free: 0, piece: piece, color: color, square: square };
                    
                    if (pieceType === 'P') {
                        const rankDelta = (piece === 'P' ? -1 : 1); 
                        let nextR1 = r + rankDelta;
                        let nextC = c;
                        
                        if (nextR1 >= 0 && nextR1 < 8) {
                            if (!board[nextR1][nextC]) {
                                pieceMobility[square].total++;
                                pieceMobility[square].free++;
                                if ((piece === 'P' && r === 6) || (piece === 'p' && r === 1)) {
                                    let nextR2 = r + 2 * rankDelta;
                                    if (nextR2 >= 0 && nextR2 < 8 && !board[nextR2][nextC]) {
                                        pieceMobility[square].total++;
                                        pieceMobility[square].free++;
                                    }
                                }
                            }
                        }
                    }

                    const vectors = MOVES[pieceType === 'P' ? piece : pieceType];
                    if (!vectors) continue;

                    const maxDist = (pieceType === 'R' || pieceType === 'B' || pieceType === 'Q') ? 8 : 1;
                    
                    vectors.forEach(move => {
                        for (let dist = 1; dist <= maxDist; dist++) {
                            let nextR = r + move.dr * dist;
                            let nextC = c + move.dc * dist;

                            if (nextR < 0 || nextR >= 8 || nextC < 0 || nextC >= 8) break;

                            const targetSquareName = getSquareName(nextR, nextC);
                            const targetPieceObj = board[nextR][nextC];
                            const targetPiece = targetPieceObj ? targetPieceObj.piece : null;
                            
                            const controlColor = color;
                            if (!controlledSquares[controlColor][targetSquareName]) {
                                controlledSquares[controlColor][targetSquareName] = [];
                            }
                            controlledSquares[controlColor][targetSquareName].push(square);
                            controlledSquares.total++;

                            if (targetPiece) {
                                const contactType = isOppositeColor(piece, targetPiece) ? 'Ataque' : 'Defesa';
                                const newContact = { 
                                    type: contactType, 
                                    attacker: square, 
                                    target: targetSquareName, 
                                    attackerPiece: piece, 
                                    targetPiece: targetPiece 
                                };
                                contacts.push(newContact);
                                
                                if (!contactsByTarget[targetSquareName]) contactsByTarget[targetSquareName] = [];
                                contactsByTarget[targetSquareName].push({ attacker: square, type: contactType, piece: piece, color: color });

                                if (!contactsByAttacker[square]) contactsByAttacker[square] = [];
                                contactsByAttacker[square].push({ target: targetSquareName, type: contactType, piece: targetPiece });

                                pieceMobility[square].total++;
                                pieceMobility[square].contacts++;
                                
                                if (maxDist > 1) break; 
                            } else {
                                if (pieceType !== 'P') {
                                    pieceMobility[square].total++;
                                    pieceMobility[square].free++;
                                }
                            }
                            
                            if (targetPiece && maxDist > 1) break;
                            if (maxDist === 1) break; 
                        }
                    });
                }
            }
            
            const blockedPieces = [];
            const limitedPieces = [];
            const LIMIT_THRESHOLD = 3;

            Object.keys(pieceMobility).forEach(square => {
                const mobility = pieceMobility[square];
                const pieceChar = mobility.piece;
                const pieceSymbol = PIECE_MAP[pieceChar];

                if (mobility.total === 0) {
                    blockedPieces.push({ square: square, piece: pieceChar, symbol: pieceSymbol });
                } else if (mobility.total < LIMIT_THRESHOLD) {
                    limitedPieces.push({ square: square, piece: pieceChar, symbol: pieceSymbol, moves: mobility.total });
                }
            });
            
            return { controlledSquares, contacts, blockedPieces, limitedPieces, pieceMobility, contactsByTarget, contactsByAttacker };
        }

        /**
         * NOVO: Identifica Pe√ßas Suspensas e Sobrecarregadas.
         */
        function analyzeTacticalVulnerabilities(board, contactsByTarget, contactsByAttacker) {
            const hanging = [];
            const overloaded = [];

            board.flat().forEach(pieceObj => {
                if (!pieceObj) return;

                const square = pieceObj.square;
                const color = pieceObj.color;
                
                // 1. Pe√ßas Suspensas (Hanging)
                const contactsToMe = contactsByTarget[square] || [];
                const myAttackers = contactsToMe.filter(c => c.type === 'Ataque');
                const myDefenders = contactsToMe.filter(c => c.type === 'Defesa');

                if (myAttackers.length > 0 && myDefenders.length === 0) {
                    hanging.push({
                        square: square,
                        piece: pieceObj.piece,
                        attackers: myAttackers.map(a => a.attacker)
                    });
                }
                
                // 2. Pe√ßas Sobrecarregadas (Overloaded)
                const contactsFromMe = contactsByAttacker[square] || [];
                const defendedPieces = contactsFromMe.filter(c => c.type === 'Defesa');
                
                if (defendedPieces.length >= 2) {
                    overloaded.push({
                        square: square,
                        piece: pieceObj.piece,
                        defending: defendedPieces.map(d => d.target)
                    });
                }
            });
            
            return { hanging, overloaded };
        }

        /**
         * Analisa as redes de composi√ß√£o (cadeias de contatos de 2 passos: A -> B -> C).
         */
        function analyzeCompositionNetworks(contactsByAttacker, contactsByTarget, board) {
            const networks = [];
            let networkIdCounter = 1; 

            Object.keys(contactsByTarget).forEach(targetB => {
                
                const pieceB_Obj = getPieceAtSquare(targetB, board); 
                if (!pieceB_Obj) return; 
                
                const contactsToB = contactsByTarget[targetB]; 
                const contactsFromB = contactsByAttacker[targetB] || []; 

                if (contactsToB.length > 0 && contactsFromB.length > 0) {
                    
                    contactsToB.forEach(contactAB => {
                        const attackerA = contactAB.attacker;
                        const typeAB = contactAB.type; 
                        const pieceA = contactAB.piece;

                        contactsFromB.forEach(contactBC => {
                            const targetC = contactBC.target;
                            const typeBC = contactBC.type; 
                            const pieceC = contactBC.piece;

                            const squares = [attackerA, targetB, targetC];
                            const uniqueSquares = Array.from(new Set(squares));
                            
                            networks.push({
                                id: networkIdCounter++, 
                                attackerA: attackerA,
                                targetB: targetB, 
                                targetC: targetC,
                                pieceA: pieceA,
                                pieceB: pieceB_Obj.piece,
                                pieceC: pieceC,
                                typeAB: typeAB,
                                typeBC: typeBC,
                                numAffectedSquares: uniqueSquares.length,
                                description: `${PIECE_MAP[pieceA]}${attackerA} ${typeAB.toLowerCase()} ${PIECE_MAP[pieceB_Obj.piece]}${targetB} que ${typeBC.toLowerCase()} ${PIECE_MAP[pieceC]}${targetC}`
                            });
                        });
                    });
                }
            });

            return networks;
        }


        /**
         * Orquestra o parsing e a an√°lise completa do FEN.
         */
        function parseAndAnalyzeFen(fen) {
            const data = parseFenToData(fen);
            if (!data.isValid) return data;

            // An√°lises de N√≠vel 1 (B√°sicas)
            const { counts, material } = analyzeMaterialAndCounts(data.board);
            data.pieceCounts = counts;
            data.material = material;
            
            // An√°lises de N√≠vel 2 (Posicionais)
            data.positionalScore = analyzePositionalScore(data.board);
            data.pawnStructure = analyzePawnStructure(data.board);
            
            // An√°lises de N√≠vel 3 (Intera√ß√µes)
            const analysis = analyzeBoard(data.board);
            data.controlledSquares = analysis.controlledSquares;
            data.contacts = analysis.contacts;
            data.blockedPieces = analysis.blockedPieces;
            data.limitedPieces = analysis.limitedPieces;
            data.contactsByTarget = analysis.contactsByTarget; 
            data.contactsByAttacker = analysis.contactsByAttacker; 
            data.pieceMobility = analysis.pieceMobility;

            // An√°lises de N√≠vel 4 (Vulnerabilidades e Redes)
            data.kingSafety = analyzeKingSafety(data.board); // (depende da pr√©-an√°lise de pe√µes)
            data.vulnerabilities = analyzeTacticalVulnerabilities(data.board, analysis.contactsByTarget, analysis.contactsByAttacker);
            data.compositionNetworks = analyzeCompositionNetworks(analysis.contactsByAttacker, analysis.contactsByTarget, data.board); 
            
            // An√°lise de N√≠vel 5 (Sumariza√ß√£o)
            data.totalScore = data.material.balance + data.positionalScore.balance;
            
            globalAnalysisResult = data;
            return data;
        }

        // --- FUN√á√ïES DE RENDERIZA√á√ÉO INTERATIVA ---
        
        const formatControllerList = (squares) => {
            if (!globalAnalysisResult || !globalAnalysisResult.board) return squares;
            return squares.map(squareName => {
                const pieceObj = getPieceAtSquare(squareName, globalAnalysisResult.board);
                if (pieceObj && pieceObj.piece) {
                    const symbol = pieceObj.piece.toUpperCase(); 
                    return symbol + squareName;
                }
                return squareName; 
            });
        };

        function applyNetworkVisualization() {
            document.querySelectorAll('.square').forEach(sq => {
                sq.classList.remove('net-dark', 'net-light');
            });
            
            if (activeNetworkId === 'none' || !globalAnalysisResult || !globalAnalysisResult.isValid) {
                document.getElementById('clear-network-button').disabled = true;
                return; 
            }
            
            document.getElementById('clear-network-button').disabled = false;

            const selectedNetwork = globalAnalysisResult.compositionNetworks.find(n => n.id === parseInt(activeNetworkId));
            
            if (selectedNetwork) {
                const piecesToHighlight = new Set();
                
                [selectedNetwork.attackerA, selectedNetwork.targetB, selectedNetwork.targetC].forEach(square => {
                    const piece = getPieceAtSquare(square, globalAnalysisResult.board);
                    if (piece && piece.piece.toLowerCase() === 'k') {
                        document.querySelector(`[data-square="${square}"]`).classList.add('net-dark');
                        piecesToHighlight.add(square); 
                    }
                });

                [selectedNetwork.attackerA, selectedNetwork.targetB, selectedNetwork.targetC].forEach(square => {
                    const piece = getPieceAtSquare(square, globalAnalysisResult.board);
                    const element = document.querySelector(`[data-square="${square}"]`);
                    
                    if (piece && (piece.piece.toLowerCase() === 'r' || piece.piece.toLowerCase() === 'p' || piece.piece.toLowerCase() === 'q')) {
                        if (!element.classList.contains('net-dark')) {
                            element.classList.add('net-light');
                            piecesToHighlight.add(square);
                        }
                    }
                });
                
                const queue = Array.from(piecesToHighlight);
                const expanded = new Set(queue);

                while (queue.length > 0) {
                    const currentSquare = queue.shift();
                    const outgoingContacts = globalAnalysisResult.contactsByAttacker[currentSquare] || [];
                    
                    outgoingContacts.forEach(contact => {
                        if (contact.type === 'Defesa') {
                            const defendedSquare = contact.target;
                            const defendedEl = document.querySelector(`[data-square="${defendedSquare}"]`);
                            
                            if (defendedEl && !defendedEl.classList.contains('net-dark') && !expanded.has(defendedSquare)) {
                                defendedEl.classList.add('net-light');
                                expanded.add(defendedSquare);
                                queue.push(defendedSquare); 
                            }
                        }
                    });
                }
            }
        }
        
        function handleSquareClick(event) {
            if (!globalAnalysisResult || !globalAnalysisResult.isValid) return;

            document.querySelectorAll('.square').forEach(sq => sq.classList.remove('highlight'));
            const clickedSquareDiv = event.currentTarget;
            clickedSquareDiv.classList.add('highlight');
            
            const squareName = clickedSquareDiv.dataset.square;
            const pieceObj = getPieceAtSquare(squareName, globalAnalysisResult.board);
            const analysis = globalAnalysisResult;
            
            // 1. L√≥gica para An√°lise da CASA
            const attackedByWhiteList = analysis.controlledSquares.white[squareName] || [];
            const attackedByBlackList = analysis.controlledSquares.black[squareName] || [];
            
            renderClickedSquareDetails({
                squareName,
                pieceObj,
                attackedByWhite: attackedByWhiteList, 
                attackedByBlack: attackedByBlackList, 
                pieceMobility: analysis.pieceMobility[squareName],
                pieceContacts: analysis.contacts.filter(c => c.attacker === squareName || c.target === squareName)
            });
            
            // 2. L√≥gica para An√°lise da PE√áA (se houver pe√ßa)
            if (pieceObj) {
                renderClickedPieceDetails({
                    squareName,
                    pieceObj,
                    pieceMobility: analysis.pieceMobility[squareName],
                    pieceContacts: analysis.contacts.filter(c => c.attacker === squareName || c.target === squareName),
                    compositionNetworks: analysis.compositionNetworks.filter(n => n.attackerA === squareName || n.targetB === squareName || n.targetC === squareName),
                    vulnerabilities: analysis.vulnerabilities
                });
            } else {
                document.getElementById('clicked-piece-details').classList.add('hidden-detail-card');
            }
            
            document.getElementById('clicked-square-details').classList.remove('hidden-detail-card');
            if (pieceObj) {
                document.getElementById('clicked-piece-details').classList.remove('hidden-detail-card');
            }
        }
        
        function renderClickedSquareDetails(details) {
            const container = document.getElementById('clicked-square-details');
            const cardElement = container.querySelector('.card');
            
            const whiteControllersSAN = formatControllerList(details.attackedByWhite);
            const blackControllersSAN = formatControllerList(details.attackedByBlack);

            const pieceSymbol = details.pieceObj ? PIECE_MAP[details.pieceObj.piece] : 'Vazia';
            const pieceChar = details.pieceObj ? details.pieceObj.piece : null;
            const pieceColor = details.pieceObj ? details.pieceObj.color : null;
            
            let mobilityStatus = 'N/A';
            if (details.pieceMobility) {
                if (details.pieceMobility.total === 0) { mobilityStatus = `<span class="status-blocked">Bloqueada</span>`; }
                else if (details.pieceMobility.total < 3) { mobilityStatus = `<span class="status-limited">Limitada (${details.pieceMobility.total} mov)</span>`; }
                else { mobilityStatus = `Alta (${details.pieceMobility.total} mov)`; }
            }

            let detailHtml = `<div class="card-header">An√°lise da Casa: ${details.squareName} (${pieceSymbol})</div>
                <ul class="metric-list">
                    <li><span>Pe√ßa na Casa:</span> <span class="metric-value">${pieceSymbol} (${pieceChar ? pieceChar : '-'})</span></li>
                    <li><span>Cor:</span> <span class="metric-value">${pieceColor ? (pieceColor === 'white' ? 'Branca' : 'Preta') : '-'}</span></li>
                    <li><span>Mob. da Pe√ßa:</span> <span class="metric-value">${mobilityStatus}</span></li>
                </ul>
                <div class="card-header" style="background-color: #777; margin-top: 10px;">Controle & Intera√ß√µes (Casa)</div>
                <ul class="metric-list">
                    <li><span>Controlada por Brancas:</span> <span class="metric-value">${whiteControllersSAN.length} pe√ßas</span></li>
                    <li><span>Controlada por Pretas:</span> <span class="metric-value">${blackControllersSAN.length} pe√ßas</span></li>
                </ul>
                <details style="margin-top: 10px; font-size: 0.9em;">
                    <summary>Detalhes do Controle</summary>
                    <p style="margin: 5px 0 0 0;">Brancas: ${whiteControllersSAN.join(', ') || 'Nenhuma'}</p>
                    <p style="margin: 5px 0 0 0;">Pretas: ${blackControllersSAN.join(', ') || 'Nenhuma'}</p>
                </details>
            `;
            cardElement.innerHTML = detailHtml;
        }

        function renderClickedPieceDetails(details) {
            const container = document.getElementById('clicked-piece-details');
            const cardElement = container.querySelector('.card');
            
            const { squareName, pieceObj, pieceMobility, pieceContacts, compositionNetworks, vulnerabilities } = details;

            const pieceSymbol = PIECE_MAP[pieceObj.piece];
            const pieceColor = pieceObj.color;
            
            let mobilityStatus = '';
            let movesList = 'N/A';
            if (pieceMobility) {
                movesList = `Livre: ${pieceMobility.free}, Contato: ${pieceMobility.contacts}`;
                if (pieceMobility.total === 0) { mobilityStatus = `<span class="status-blocked">Bloqueada (0 mov)</span>`; }
                else if (pieceMobility.total < 3) { mobilityStatus = `<span class="status-limited">Limitada (${pieceMobility.total} mov)</span>`; }
                else { mobilityStatus = `Boa (${pieceMobility.total} mov)`; }
            }

            // NOVO: Verificar status de vulnerabilidade
            let vulnerabilityStatus = 'Segura';
            if (vulnerabilities.hanging.some(p => p.square === squareName)) {
                vulnerabilityStatus = `<span class="status-hanging">üî¥ SUSPENSA (Atacada e Indefesa)</span>`;
            } else if (vulnerabilities.overloaded.some(p => p.square === squareName)) {
                vulnerabilityStatus = `<span class="status-overloaded">üü† SOBRECARREGADA (Defende ${vulnerabilities.overloaded.find(p=>p.square === squareName).defending.length} pe√ßas)</span>`;
            }

            // Agrupar intera√ß√µes
            const attacks = pieceContacts.filter(c => c.type === 'Ataque' && c.attacker === squareName);
            const defenses = pieceContacts.filter(c => c.type === 'Defesa' && c.attacker === squareName);
            const targets = pieceContacts.filter(c => c.target === squareName); 
            
            const uniqueNetworks = Array.from(new Set(compositionNetworks.map(n => n.description))).map(desc => compositionNetworks.find(n => n.description === desc));

            let detailHtml = `<div class="card-header" style="background-color: ${pieceColor === 'white' ? '#4a76a8' : '#333'}; color: white;">An√°lise da Pe√ßa: ${pieceSymbol} em ${squareName}</div>
                
                <div class="card-header" style="background-color: #f0f0f0; color: #333; margin-top: 10px;">Situa√ß√£o e Mobilidade</div>
                <ul class="metric-list">
                    <li><span>Cor:</span> <span class="metric-value">${pieceColor === 'white' ? 'Branca' : 'Preta'}</span></li>
                    <li><span>Status T√°tico:</span> <span class="metric-value">${vulnerabilityStatus}</span></li>
                    <li><span>Status da Mobilidade:</span> <span class="metric-value">${mobilityStatus}</span></li>
                    <li><span>Detalhamento dos Movimentos:</span> <span class="metric-value">${movesList}</span></li>
                </ul>

                <div class="card-header" style="background-color: #f0f0f0; color: #333; margin-top: 10px;">Intera√ß√µes Pe√ßa-Pe√ßa</div>
                <ul class="metric-list">
                    <li><span>Ataca:</span> <span class="metric-value" style="color: red; font-weight: bold;">${attacks.length} pe√ßas</span></li>
                    <li><span>Defende:</span> <span class="metric-value" style="color: blue; font-weight: bold;">${defenses.length} pe√ßas</span></li>
                    <li><span>Alvo de Contato:</span> <span class="metric-value">${targets.length} pe√ßas</span></li>
                </ul>
                
                <div class="card-header" style="background-color: var(--network-color); color: white; margin-top: 10px;">Redes de Composi√ß√£o</div>
                <ul class="metric-list">
                    <li><span>Redes Envolvidas:</span> <span class="metric-value network">${uniqueNetworks.length}</span></li>
                </ul>

                <details style="margin-top: 10px; font-size: 0.9em;">
                    <summary>Detalhes das Intera√ß√µes (${pieceContacts.length})</summary>
                    <p style="margin: 5px 0 0 0; font-weight: bold;">Alvos da Pe√ßa (${pieceSymbol}${squareName}):</p>
                    ${attacks.map(c => `<div class="contact-item"><span class="attack">Ataca:</span> ${PIECE_MAP[c.targetPiece]}${c.target}</div>`).join('') || '<div class="contact-item">Nenhum ataque.</div>'}
                    ${defenses.map(c => `<div class="contact-item"><span class="defense">Defende:</span> ${PIECE_MAP[c.targetPiece]}${c.target}</div>`).join('') || '<div class="contact-item">Nenhuma defesa.</div>'}
                    <p style="margin: 10px 0 0 0; font-weight: bold;">Pe√ßas Interagindo com Ela:</p>
                    ${targets.map(c => {
                        const type = c.type === 'Ataque' ? 'attack' : 'defense';
                        const verb = c.type === 'Ataque' ? 'Atacada por' : 'Defendida por';
                        return `<div class="contact-item"><span class="${type}">${verb}:</span> ${PIECE_MAP[c.attackerPiece]}${c.attacker}</div>`;
                    }).join('') || '<div class="contact-item">Nenhuma.</div>'}
                </details>

                <details style="margin-top: 10px; font-size: 0.9em;">
                    <summary>Detalhes das Redes (${uniqueNetworks.length})</summary>
                    ${uniqueNetworks.length > 0 ? uniqueNetworks.map(n => 
                        `<div class="contact-item"><span class="network">Rede #${n.id}:</span> ${n.description}</div>`
                    ).join('') : '<p style="margin: 5px 0 0 0;">Nenhuma rede de composi√ß√£o de 2 passos encontrada.</p>'}
                </details>
            `;
            cardElement.innerHTML = detailHtml;
            document.getElementById('clicked-piece-details').classList.remove('hidden-detail-card');
        }

        function renderBoard(board) {
            const container = document.getElementById('chessboard-container');
            container.innerHTML = '';
            
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const square = document.createElement('div');
                    const squareName = `${FILES[c]}${RANKS[r]}`;
                    
                    square.className = 'square';
                    square.dataset.square = squareName; 
                    square.addEventListener('click', handleSquareClick);
                    
                    if ((r + c) % 2 === 0) { square.classList.add('light'); } else { square.classList.add('dark'); }

                    const pieceObj = board[r][c];
                    if (pieceObj && pieceObj.piece) {
                        const pieceCode = pieceObj.piece;
                        square.textContent = PIECE_MAP[pieceCode];
                        if (pieceCode === pieceCode.toUpperCase()) { square.classList.add('white-piece'); } else { square.classList.add('black-piece'); }
                    }
                    container.appendChild(square);
                }
            }
            const rankContainer = document.getElementById('rank-coords');
            const fileContainer = document.getElementById('file-coords');
            rankContainer.innerHTML = '';
            fileContainer.innerHTML = '';
            RANKS.forEach(rank => { const div = document.createElement('div'); div.textContent = rank; rankContainer.appendChild(div); });
            FILES.forEach(file => { const div = document.createElement('div'); div.textContent = file; fileContainer.appendChild(div); });
            
            applyNetworkVisualization();
        }
        
        function populateNetworkSelector(networks) {
            const selector = document.getElementById('network-selector');
            const clearButton = document.getElementById('clear-network-button');
            selector.innerHTML = '<option value="none">Nenhuma</option>';
            
            if (!networks || networks.length === 0) {
                selector.disabled = true;
                clearButton.disabled = true;
                return;
            }
            
            const uniqueNetworksMap = new Map();
            networks.forEach(n => {
                if (!uniqueNetworksMap.has(n.description)) {
                    uniqueNetworksMap.set(n.description, n);
                }
            });
            let uniqueNetworks = Array.from(uniqueNetworksMap.values());
            uniqueNetworks.sort((a, b) => b.numAffectedSquares - a.numAffectedSquares);

            selector.disabled = false;
            
            let newId = 1;
            uniqueNetworks.forEach(network => {
                network.id = newId++; 
                const option = document.createElement('option');
                option.value = network.id;
                option.textContent = `#${network.id} (${network.numAffectedSquares} casas): ${PIECE_MAP[network.pieceA]}${network.attackerA} ü°í ${PIECE_MAP[network.pieceB]}${network.targetB} ü°í ${PIECE_MAP[network.pieceC]}${network.targetC}`;
                selector.appendChild(option);
            });
            
            if (activeNetworkId !== 'none') {
                 const oldNetworkDescription = networks.find(n => n.id === parseInt(activeNetworkId))?.description;
                 const foundNew = uniqueNetworks.find(n => n.description === oldNetworkDescription);
                 activeNetworkId = foundNew ? foundNew.id : 'none';
            }

            selector.value = activeNetworkId;
            clearButton.disabled = (activeNetworkId === 'none');
        }

        function handleNetworkSelectorChange(event) {
            activeNetworkId = event.target.value;
            applyNetworkVisualization();
        }
        
        function handleClearNetwork() {
            activeNetworkId = 'none';
            document.getElementById('network-selector').value = 'none';
            applyNetworkVisualization(); 
            document.getElementById('clear-network-button').disabled = true;
        }


        /**
         * Renderiza os pain√©is de An√°lise Geral do FEN.
         */
        function renderPositionData(analysisResult) {
            const panel = document.getElementById('analysis-results');
            panel.innerHTML = '';

            if (!analysisResult.isValid) {
                panel.innerHTML = `<p style="color:red; font-weight:bold;">Erro: ${analysisResult.message}</p>`;
                return;
            }
            
            const contacts = analysisResult.contacts;
            const blocked = analysisResult.blockedPieces;
            const limited = analysisResult.limitedPieces;
            const networks = analysisResult.compositionNetworks;
            
            populateNetworkSelector(networks);
            
            const uniqueNetworks = Array.from(new Set(networks.map(n => n.description)))
                                    .map(desc => networks.find(n => n.description === desc)); 
            uniqueNetworks.sort((a, b) => b.numAffectedSquares - a.numAffectedSquares); 

            let networkHtml = `<div class="card-header" style="background-color: var(--network-color); color: white;">üîó Redes de Composi√ß√£o Global</div>
                <ul class="metric-list">
                    <li><span>Total de Redes (2-Passos):</span> <span class="metric-value network">${uniqueNetworks.length}</span></li>
                </ul>
                <details style="margin-top: 10px; max-height: 200px; overflow-y: auto;">
                    <summary>Clique para Ver Detalhes das Redes</summary>
                    <p style="margin: 10px 0 5px 0; font-weight: bold; color: var(--network-color);">Redes (Ordem de Impacto):</p>
                    ${uniqueNetworks.map(n => 
                        `<div class="contact-item"><span class="network">Rede #${n.id} (${n.numAffectedSquares} casas):</span> ${n.description}</div>`
                    ).join('')}
                    ${uniqueNetworks.length === 0 ? '<div class="contact-item">Nenhuma rede de composi√ß√£o de 2 passos encontrada.</div>' : ''}
                </details>`;
            panel.innerHTML += `<div class="card">${networkHtml}</div>`;

            let mobilityHtml = `<div class="card-header">üöß Bloqueio e Limita√ß√£o</div>
                <ul class="metric-list">
                    <li><span>Pe√ßas Bloqueadas (0 mov.):</span> <span class="metric-value status-blocked">${blocked.length}</span></li>
                    <li><span>Pe√ßas Limitadas (< 3 mov.):</span> <span class="metric-value status-limited">${limited.length}</span></li>
                </ul>
                <details style="margin-top: 10px; max-height: 200px; overflow-y: auto; font-size: 0.9em;">
                    <summary>Detalhes (Bloqueadas/Limitadas)</summary>
                    <p style="margin: 5px 0 0 0;"><span class="status-blocked">Bloqueadas:</span> ${blocked.map(p => `${p.symbol}${p.square}`).join(', ') || 'Nenhuma'}</p>
                    <p style="margin: 5px 0 0 0;"><span class="status-limited">Limitadas:</span> ${limited.map(p => `${p.symbol}${p.square} (${p.moves} mov)`).join(', ') || 'Nenhuma'}</p>
                </details>`;
            panel.innerHTML += `<div class="card">${mobilityHtml}</div>`;

            const attacks = contacts.filter(c => c.type === 'Ataque');
            const defenses = contacts.filter(c => c.type === 'Defesa');
            
            let contactsHtml = `<div class="card-header">‚öîÔ∏è Pontos de Contato</div>
                <ul class="metric-list">
                    <li><span>Total de Contatos:</span> <span class="metric-value">${contacts.length}</span></li>
                    <li><span>Ataques:</span> <span class="metric-value" style="color: red;">${attacks.length}</span></li>
                    <li><span>Defesas:</span> <span class="metric-value" style="color: blue;">${defenses.length}</span></li>
                </ul>
                <details style="margin-top: 10px; max-height: 200px; overflow-y: auto;">
                    <summary>Clique para Ver Detalhes (Ataques/Defesas)</summary>
                    <p style="margin: 10px 0 5px 0; font-weight: bold; color: red;">Ataques (Pe√ßa ü°í Alvo):</p>
                    ${attacks.map(a => {
                        const attackerSymbol = PIECE_MAP[a.attackerPiece];
                        const targetSymbol = PIECE_MAP[a.targetPiece];
                        return `<div class="contact-item"><span class="attack">Ataque:</span> ${attackerSymbol}${a.attacker} ü°í ${targetSymbol}${a.target}</div>`;
                    }).join('') || '<div class="contact-item">Nenhum ataque.</div>'}
                    
                    <p style="margin: 10px 0 5px 0; font-weight: bold; color: blue;">Defesas (Pe√ßa ü°í Amigo):</p>
                    ${defenses.map(d => {
                        const attackerSymbol = PIECE_MAP[d.attackerPiece];
                        const targetSymbol = PIECE_MAP[d.targetPiece];
                        return `<div class="contact-item"><span class="defense">Defesa:</span> ${attackerSymbol}${d.attacker} ü°í ${targetSymbol}${d.target}</div>`;
                    }).join('') || '<div class="contact-item">Nenhuma defesa.</div>'}
                </details>`;
            panel.innerHTML += `<div class="card">${contactsHtml}</div>`;
        }


        // --- FUN√á√ïES DE VIS√ÉO GERAL E NOVOS RENDERERS ---

        /**
         * Renderiza a lista de Vis√£o Geral de Pe√ßas no painel.
         */
        function renderBoardOverview(analysisResult) {
            const listContainer = document.getElementById('overview-list');
            listContainer.innerHTML = '';

            if (!analysisResult || !analysisResult.isValid) {
                 listContainer.innerHTML = `<li>Aguardando FEN v√°lido...</li>`;
                 return;
            }

            const pieceList = Object.keys(analysisResult.pieceMobility).map(square => {
                const mobility = analysisResult.pieceMobility[square];
                const piece = mobility.piece;
                const symbol = PIECE_MAP[piece];
                
                let statusClass = '';
                let statusText = `${mobility.total} mov`;

                // Prioridade de Status
                if (analysisResult.vulnerabilities.hanging.some(p => p.square === square)) {
                    statusClass = 'status-hanging'; statusText = 'üî¥ SUSPENSA';
                } else if (analysisResult.vulnerabilities.overloaded.some(p => p.square === square)) {
                    statusClass = 'status-overloaded'; statusText = 'üü† SOBRECARREGADA';
                } else if (mobility.total === 0) {
                    statusClass = 'status-blocked'; statusText = 'BLOQUEADA';
                } else if (mobility.total < 3) {
                    statusClass = 'status-limited'; statusText = `LIMITADA (${mobility.total})`;
                }

                return { square, piece, symbol, statusClass, statusText };
            });
            
            if (pieceList.length === 0) {
                 listContainer.innerHTML = `<li>Nenhuma pe√ßa encontrada.</li>`;
                 return;
            }

            pieceList.forEach(item => {
                const listItem = document.createElement('li');
                listItem.innerHTML = `
                    <span>${item.symbol}${item.square}</span>
                    <span class="${item.statusClass}">${item.statusText}</span>
                `;
                listItem.style.cursor = 'pointer';
                listItem.addEventListener('click', () => {
                    const squareDiv = document.querySelector(`[data-square="${item.square}"]`);
                    if (squareDiv) {
                        squareDiv.click(); 
                        document.getElementById('analysis-panel').scrollTop = 0; 
                    }
                });
                listContainer.appendChild(listItem);
            });
        }
        
        /** NOVO: Renderiza o sum√°rio de pontua√ß√£o */
        function renderScoreSummary(analysisResult) {
            const scoreDisplay = document.getElementById('total-score-display');
            const breakdownDisplay = document.getElementById('score-breakdown');
            
            if (!analysisResult || !analysisResult.isValid) {
                scoreDisplay.textContent = 'N/A';
                breakdownDisplay.textContent = 'Aguardando FEN v√°lido';
                return;
            }
            
            const totalScore = analysisResult.totalScore;
            const material = analysisResult.material.balance;
            const position = analysisResult.positionalScore.balance;
            
            let scoreText = totalScore.toFixed(2);
            if (totalScore > 0) {
                scoreText = `+${scoreText}`;
                scoreDisplay.style.color = 'white';
            } else if (totalScore < 0) {
                scoreDisplay.style.color = '#ffcdd2';
            } else {
                scoreDisplay.style.color = 'white';
            }
            
            scoreDisplay.textContent = scoreText;
            breakdownDisplay.textContent = `(Material: ${material.toFixed(2)}, Posi√ß√£o: ${position.toFixed(2)})`;
        }
        
        /** NOVO: Renderiza o balan√ßo material */
        function renderMaterialBalance(analysisResult) {
            const container = document.getElementById('material-balance-list');
            container.innerHTML = '';
            
            if (!analysisResult || !analysisResult.isValid) {
                container.innerHTML = `<li>Aguardando FEN v√°lido...</li>`;
                return;
            }
            
            const material = analysisResult.material;
            const balance = material.balance;
            
            let balanceText = `${balance.toFixed(1)}`;
            let balanceClass = '';
            if (balance > 0) {
                balanceText = `+${balance.toFixed(1)} (Brancas)`;
                balanceClass = 'positive';
            } else if (balance < 0) {
                balanceText = `${balance.toFixed(1)} (Pretas)`;
                balanceClass = 'negative';
            } else {
                balanceText = `Equilibrado`;
            }
            
            container.innerHTML = `
                <li><span>Total Brancas:</span> <span class="metric-value">${material.white}</span></li>
                <li><span>Total Pretas:</span> <span class="metric-value">${material.black}</span></li>
                <li style="border-top: 2px solid #ccc; padding-top: 5px; margin-top: 5px;">
                    <strong>Vantagem:</strong>
                    <span class="metric-value ${balanceClass}">${balanceText}</span>
                </li>
            `;
        }
        
        /** NOVO: Renderiza a pontua√ß√£o posicional */
        function renderPositionalScore(analysisResult) {
            const container = document.getElementById('positional-score-list');
            container.innerHTML = '';

            if (!analysisResult || !analysisResult.isValid) {
                container.innerHTML = `<li>Aguardando FEN v√°lido...</li>`;
                return;
            }

            const score = analysisResult.positionalScore;
            const balance = score.balance; // J√° est√° em pe√µes (dividido por 100)
            
            let balanceText = `${balance.toFixed(2)}`;
            let balanceClass = '';
            if (balance > 0) {
                balanceText = `+${balance.toFixed(2)} (Brancas)`;
                balanceClass = 'positive';
            } else if (balance < 0) {
                balanceText = `${balance.toFixed(2)} (Pretas)`;
                balanceClass = 'negative';
            } else {
                balanceText = `Equilibrado`;
            }

            container.innerHTML = `
                <li><span>Total Brancas (centipawns):</span> <span class="metric-value">${score.white}</span></li>
                <li><span>Total Pretas (centipawns):</span> <span class="metric-value">${score.black}</span></li>
                <li style="border-top: 2px solid #ccc; padding-top: 5px; margin-top: 5px;">
                    <strong>Vantagem:</strong>
                    <span class="metric-value ${balanceClass}">${balanceText}</span>
                </li>
            `;
        }

        /** NOVO: Renderiza a estrutura de pe√µes */
        function renderPawnStructure(analysisResult) {
            const container = document.getElementById('pawn-structure-analysis');
            container.innerHTML = '';
            
            if (!analysisResult || !analysisResult.isValid) {
                container.innerHTML = `<p>Aguardando FEN v√°lido...</p>`;
                return;
            }
            
            const s = analysisResult.pawnStructure;
            
            const renderSection = (title, color, data) => {
                const style = color === 'white' ? 'card-header-white' : 'card-header-black';
                return `
                    <div class="card-header ${style}" style="font-size: 1em; padding: 5px 10px; margin: 10px -15px 5px -15px;">${title}</div>
                    <ul class="metric-list" style="font-size: 0.9em;">
                        <li><span>Dobrados:</span> <span class="metric-value ${data.doubled.length > 0 ? 'negative' : ''}">${data.doubled.join(', ') || 'Nenhum'}</span></li>
                        <li><span>Isolados:</span> <span class="metric-value ${data.isolated.length > 0 ? 'negative' : ''}">${data.isolated.join(', ') || 'Nenhum'}</span></li>
                        <li><span>Passados:</span> <span class="metric-value ${data.passed.length > 0 ? 'positive' : ''}">${data.passed.join(', ') || 'Nenhum'}</span></li>
                    </ul>
                `;
            };
            
            container.innerHTML = renderSection('Brancas', 'white', s.white) + renderSection('Pretas', 'black', s.black);
        }
        
        /** NOVO: Renderiza a seguran√ßa do rei */
        function renderKingSafety(analysisResult) {
            const container = document.getElementById('king-safety-analysis');
            container.innerHTML = '';

            if (!analysisResult || !analysisResult.isValid) {
                container.innerHTML = `<p>Aguardando FEN v√°lido...</p>`;
                return;
            }
            
            const s = analysisResult.kingSafety;

            const renderSection = (title, color, data) => {
                const style = color === 'white' ? 'card-header-white' : 'card-header-black';
                let shieldText = `${data.shield} / 3`;
                let shieldClass = data.shield >= 2 ? 'positive' : (data.shield <= 0 ? 'negative' : '');
                
                let filesText = data.openFiles.map(f => `${f.file} (${f.type})`).join(', ') || 'Nenhum';
                let filesClass = data.openFiles.length > 0 ? 'negative' : '';

                return `
                    <div class="card-header ${style}" style="font-size: 1em; padding: 5px 10px; margin: 10px -15px 5px -15px;">${title}</div>
                    <ul class="metric-list" style="font-size: 0.9em;">
                        <li><span>Escudo de Pe√µes:</span> <span class="metric-value ${shieldClass}">${shieldText}</span></li>
                        <li><span>Arquivos Pr√≥ximos:</span> <span class="metric-value ${filesClass}">${filesText}</span></li>
                    </ul>
                `;
            };
            
            container.innerHTML = renderSection('Rei Branco', 'white', s.white) + renderSection('Rei Preto', 'black', s.black);
        }

        // --- FUN√á√ïES DE CONTROLE DE EXPANS√ÉO (DETALHES) ---
        function closeOtherDetails(targetDetails = null) {
            document.querySelectorAll('details').forEach(detail => {
                if (detail !== targetDetails) {
                    detail.open = false;
                }
            });
        }
        
        function hideDetailPanels() {
            document.getElementById('clicked-square-details').classList.add('hidden-detail-card');
            document.getElementById('clicked-piece-details').classList.add('hidden-detail-card');
            document.querySelectorAll('.square').forEach(sq => sq.classList.remove('highlight'));
        }

        function handleGlobalClick(event) {
            const clickedElement = event.target;
            
            const keepOpenElements = [
                document.getElementById('analysis-panel'),
                document.getElementById('board-wrapper'),
                document.getElementById('clear-network-button')
            ];

            const isInsideProtectedArea = keepOpenElements.some(el => el && el.contains(clickedElement) || clickedElement.closest('#analysis-panel'));

            if (!isInsideProtectedArea) {
                hideDetailPanels();
                closeOtherDetails(null);
                return; 
            }
            
            const clickedDetails = clickedElement.closest('details');

            if (clickedDetails) {
                setTimeout(() => {
                    closeOtherDetails(clickedDetails);
                }, 1);
            } else {
                if (!clickedElement.closest('#board-overview')) {
                    closeOtherDetails(null);
                }
            }
        }

        // --- INICIALIZA√á√ÉO E MANIPULA√á√ÉO PRINCIPAL ---
        function handleParseAndRender() {
            const fenInput = document.getElementById('fen-input').value.trim();
            const validationMessage = document.getElementById('validation-message');
            
            const analysisResult = parseAndAnalyzeFen(fenInput);

            if (analysisResult.isValid) {
                validationMessage.textContent = 'SUCESSO: FEN v√°lido e analisado. Clique em uma casa para mais detalhes.';
                validationMessage.style.color = 'green';
                globalAnalysisResult = analysisResult;
                renderBoard(analysisResult.board);
            } else {
                validationMessage.textContent = `ERRO: ${analysisResult.message}`;
                validationMessage.style.color = 'red';
                globalAnalysisResult = null;
                document.getElementById('chessboard-container').innerHTML = '';
            }

            handleClearNetwork();
            
            // NOVO: Renderiza todos os novos pain√©is
            renderScoreSummary(analysisResult);
            renderMaterialBalance(analysisResult);
            renderPositionalScore(analysisResult);
            renderPawnStructure(analysisResult);
            renderKingSafety(analysisResult);
            
            // Renderiza os pain√©is antigos
            renderPositionData(analysisResult); 
            renderBoardOverview(analysisResult); 
            
            hideDetailPanels();
            closeOtherDetails(null);
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('parse-button').addEventListener('click', handleParseAndRender);
            document.getElementById('network-selector').addEventListener('change', handleNetworkSelectorChange);
            document.getElementById('clear-network-button').addEventListener('click', handleClearNetwork);
            handleParseAndRender(); 
            document.addEventListener('click', handleGlobalClick);
        });

    </script>
</body>
</html>
